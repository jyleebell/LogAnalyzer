/*
Log Analyzer 
  Author: Soc Design Lab. Jbnu
  Function: Analyze the log files from a battery gauge and find instruction patterns
*/
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<unistd.h>
#include<ctype.h>
#include<setjmp.h>

#include<igraph.h>

#include "codeGen.h"
#include "util.h"
#include "print.h"
#include "opList.h"
#include "pattern.h"
#include "iso.h"


char *operandNameStrs[] = {
  "GR0_L", 
  "GR0_H", 
  "GR1_L", 
  "GR1_H", 
  "GR2_L", 
  "GR2_H", 
  "GR3_L", 
  "GR3_H", 
  "GR4_L", 
  "GR4_H", 
  "GR5_L", 
  "GR5_H", 
  "GR6_L", 
  "GR6_H", 
  "GR7_L", 
  "GR7_H", 
  "ST1_L",
  "ST1_H",
  "ST2_L",
  "ST2_H",
  "IN_X",
  "PCIB_L", 
  "PCIB_H", 
  "PCI_A_L",
  "PCI_A_H",
  "IR_BUF_H",
  "IR_BUF_L",
  "IR_BUF",		// immediate area
  "SFR_S0",		// may be ACC
  "SFR_S1",
  "SFR_S2",
  "SFR_S3",
  "SFR_S4",
  "SFR",		// SFR[xx]: xx is an address.
  "SRAM",		// SRAM[xxx]: xxx is an address.
  "ALU0_L",
  "ALU0_H",
  "ALU1_L",
  "ALU1_H",
  "ALU2_L",
  "ALU2_H",
  "EEP1",
  "EEP2_I",
  "EEP2_M",
  "LSB",
  "MSB",
  "CONST"
};

char *operatorNameStrs[] = {
  "ADD",
  "SUB",
  "MULT",
  "DIV",
  "RSHIFT",
  "LSHIFT",
  "OR",
  "AND",
  "XOR",
  "NOT",
  "MOVE",
  "MOVEC",
  "ALUMOVE",
  "RESET"
};

char *operators[] = {
  "+",
  "-",
  "*",
  "/",
  ">>",
  "<<",
  "|",
  "&",
  "^",
  "~",
  "MOVE",
  "MOVEC",
  "ALUMOVE",
  "RESET"
};

/*
 * Line number begins at 1 but ID of a node begins with 0;
 * If the line number range (to be analyzed) is from 1001 to 2000,
 * the ID of nodes ranges from 0 to 999.
 * The ID of the node correspoding to line number is calucated by using equation "NodeID = LineNo - nodeIDOffset".
 * When the range spans from line number 1001 to line number 2000 (offset is 1001),
 * the ID of the node containing Line 1500 (line number is 1500) is 1500 - 1001 = 499. 
 * nodeIDOffset is set per analysis.
 */
unsigned long nodeIDOffset = 0;
unsigned long noOfGraphNodes = 0;
OpDListNode *startNode, *endNode;
int isFirstInGroup = 0;
FILE *resultFP;
line_no_t startLine = 0, endLine = 0;

extern PATTERN_NODE *pattern_head;
extern PATTERN_NODE *pattern_tail;


/*
 typedef struct operand_t {
   OPERAND_TYPE type;
   value_t value;
   byte_t mask;
   addr_t addr;
   byte_t bitPos;
   byte_t isMSB;  // for MULT LSB or MSB
   byte_t ext;
   byte_t carry;
   byte_t bitWiseNot;
 } OPERAND;
 */

int
isEqualOperand(OPERAND *opnd0, OPERAND *opnd1) {
  if (opnd0->type == opnd1->type
      && opnd0->value == opnd1->value
      // && opnd0->mask == opnd1->mask
      && opnd0->addr == opnd1->addr
      // && opnd0->bitPos == opnd1->bitPos
      // && opnd0->isMSB == opnd1->isMSB
      // && opnd0->ext == opnd1->ext
      && opnd0->carry == opnd1->carry
      && opnd0->bitWiseNot == opnd1->bitWiseNot
    )
    return 1;
  else
    return 0;
}

/*
 typedef struct operation_t {
   OPERATOR op;
   OPERAND *dest;
   OPERAND *src[2];
 } OPERATION;
 */
int
isEqualOperation(OPERATION *op0, OPERATION *op1) {
  if (op0->op == op1->op) {
    if (isEqualOperand(op0->dest, op1->dest)
        && op0->src[0] && op1->src[0] && isEqualOperand(op0->src[0], op1->src[0])
        && op0->src[1] && op1->src[1] && isEqualOperand(op0->src[1], op1->src[1])
        )
      return 1;
    else
      return 0;
  } else
    return 0;
}

char *
getClk(char *lineStr, clk_t *clkP) {
  char *end, *start;
  lineStr = skipWhiteSpaces(lineStr);

  /* CLK[XXXXXXXX] */
  if (toupper(lineStr[0]) != 'C' ||
	  toupper(lineStr[1]) != 'L' ||
	  toupper(lineStr[2]) != 'K' ||
	  toupper(lineStr[3]) != '[') {
		fprintf(stderr, "Clock error: %s\n", lineStr);
		exit(CLK_ERR);
	  }
  lineStr += 4;
  start = lineStr;
  end = strchr(start, ']');
  lineStr = end + 1;
  *end = 0;

  *clkP = (clk_t) strtol(start, NULL, 16);

  return lineStr;
}

char *
getPC(char *lineStr, pc_t *pcP) {
  char *end, *start;
  lineStr = skipWhiteSpaces(lineStr);

  /* PC[XXXXXXXX] */
  if (toupper(lineStr[0]) != 'P' ||
	  toupper(lineStr[1]) != 'C' ||
	  toupper(lineStr[2]) != '[') {
		fprintf(stderr, "PC error: %s\n", lineStr);
		exit(PC_ERR);
	  }
  lineStr += 3;
  start = lineStr;
  end = strchr(start, ']');
  lineStr = end + 1;
  *end = 0;

  *pcP = (pc_t) strtol(start, NULL, 16);

  return lineStr;
}

char *
getFieldA(char *lineStr, byte_t *fieldP) {
  char *end, *start;
  lineStr = skipWhiteSpaces(lineStr);

  /* [XX] */
  if (toupper(lineStr[0]) != '[') {
		fprintf(stderr, "FieldA error: %s\n", lineStr);
		exit(FIELDA_ERR);
	  }
  lineStr += 1;
  start = lineStr;
  end = strchr(start, ']');
  lineStr = end + 1;
  *end = 0;

  *fieldP = (byte_t) strtol(start, NULL, 16);

  return lineStr;
}

char *
getFieldB(char *lineStr, byte_t *fieldP) {
  char *end, *start;
  lineStr = skipWhiteSpaces(lineStr);

  /* [XX] */
  if (toupper(lineStr[0]) != '[') {
		fprintf(stderr, "FieldB error: %s\n", lineStr);
		exit(FIELDB_ERR);
	  }
  lineStr += 1;
  start = lineStr;
  end = strchr(start, ']');
  lineStr = end + 1;
  *end = 0;

  *fieldP = (byte_t) strtol(start, NULL, 16);

  return lineStr;
}

char *
getOpName(char *lineStr, char *opName) {
  char *end, *start;
  lineStr = skipWhiteSpaces(lineStr);
  start = lineStr;

  /* opName // */
  end = strstr(start, "//");
  if (end == NULL) {
		fprintf(stderr, "OP NAME error: %s\n", lineStr);
		exit(OPNAME_ERR);
	  }
  *end = 0;
  lineStr = end + 2;
  strcpy(opName, start);

  return lineStr;
}

int
getOperandsStr (char *lineStr, char **srcOperandsStr, char **destOperandStr) {
  char *start;
  start = skipWhiteSpaces(lineStr);

  *destOperandStr = strstr(start, "->");
  *destOperandStr += 3;
  *destOperandStr = skipWhiteSpaces(*destOperandStr);
  *srcOperandsStr = start;
  *(*destOperandStr-4) = 0;

  return 0;
}

char * 
parseOperand(char *lineStr, OPERAND *opP) {
  int noOperandTypes = (int) (sizeof(operandNameStrs)/sizeof(char *));
  int i;
  char *start = skipWhiteSpaces(lineStr);
  char *end;
  OPERAND_TYPE opndType = 0;
  value_t opndValue = -1;
  byte_t opndMask = 0xFF;
  addr_t address = -1;
  byte_t bitPos = 0xFF;
  byte_t isMSB = 0xF;
  byte_t ext = 0xFF;
  byte_t carry = 0xFF;
  byte_t bitWiseNot = 0;


  if(start[0] == '~') {
	bitWiseNot = 1;
	start++;
  }
  opP->bitWiseNot = bitWiseNot;

  if (start[0] == '(') {
	start++;
	end = strchr(start, ')');
	if (end == NULL) {
	  fprintf(stderr, "Constant operand syntax error: ) is missing\n");
	  exit(CONST_OP_ERR);
	}
	*end = 0;
	opndValue = (unsigned int) strtol(start, NULL, 16);
	start = end + 1;

	start = skipWhiteSpaces(start);
	if (strstr(start, "LSB") != NULL) isMSB = 0;
	else if (strstr(start, "MSB") != NULL) isMSB = 1;

	opP->type = CONST;
	opP->value = opndValue;
	opP->mask = opndMask;
	opP->addr = address;
	opP->bitPos = bitPos;
	opP->isMSB = isMSB;
	opP->ext = ext;
	opP->carry = carry;

	return start;
  }
  else {
	for (i = 0; i < noOperandTypes; i++) {
	  if (strstr(start, operandNameStrs[i])) {
		/* found a matching operand */
		opndType = (OPERAND_TYPE) i;
		start += strlen(operandNameStrs[i]);

		if (opndType == PCIB_H && start[0] == '.') {
		  if (start[0] == '.' && start[2] == ',') {
			bitPos = start[1] - '0';
			if (bitPos < 0 || bitPos >= 8) {
			  fprintf(stderr, "Bit value error in PCIB_H.<bit postion>. bit position must be >= 0 and <= 7\n");
			  exit(BITPOS_VALUE_ERR);
			}
		  } else {
			fprintf(stderr, "Bit position syntax error in PCIB_H.<bit postion>,(value)\n");
			exit(BITPOS_SYNTAX_ERR);
		  }
		  start += 3;
		} else if (opndType == SFR || opndType == SRAM || opndType == EEP2_I || opndType == EEP2_M || opndType == EEP1) {
		  if (start[0] == '[') {
			start++;
			end = strchr(start, ']');
			if (end == NULL) {
			  fprintf(stderr, "%s address error. ] is missing.\n", opndType == SFR ? "SFR" : "SRAM");
			  exit(SFR_SRAM_ADDR_ERR);
			}
			*end = 0;
			address = (unsigned int) strtol(start, NULL, 16);
			start = end + 1;
		  } else {
			fprintf(stderr, "%s address error. [ is missing.\n", opndType == SFR ? "SFR" : "SRAM");
			exit(SFR_SRAM_ADDR_ERR);
		  }
		} 

		/* At this location of the input, (value) is seen. 
		   After (value), (m) can be placed optionally. 
		   */
		start = skipWhiteSpaces(start);
		if (start[0] == '(') {
		  end = strchr(start+1, ')');
		  if (end == NULL) {
			fprintf(stderr, "value error: ) is missing.\n");
			exit(VALUE_ERR);
		  }
		  *end = 0;
		  start++;
		  opndValue = (value_t) strtol(start, NULL, 16);
		  start = end + 1;
		} else {
		  fprintf(stderr, "value error: ( is missing.\n");
		  exit(VALUE_ERR);
		}

		start = skipWhiteSpaces(start);
		if (start[0] == '(') {
		  /* (m) is present */
		  char temp;
		  end = strchr(start+1, ')');
		  if (end == NULL) {
			fprintf(stderr, "mask error: ) is missing.\n");
			exit(MASK_ERR);
		  }
		  temp = *end;
		  *end = 0;
		  start++;
		  opndMask = (byte_t) strtol(start, NULL, 16);
		  *end = temp;
		  start = end + 1;
		} 

		start = skipWhiteSpaces(start);
		if (start[0] == ',') {
		  /*
			In source operand, ",(b)" can appear after mask.
			clk[00133daf]pc[000069ee][01][07] alu // SFR_S1(00)(1),(1) >> (1) -> PCIB_L(80)
			clk[00133db5]pc[000069e8][01][07] alu // SFR_S1(00)(1),(0) >> (1) -> GR5_H(00)
		  */
		  start += 2;
		  ext = *start - '0';
		  start += 2;
		}

		start = skipWhiteSpaces(start);
		/* MSB, LSB, + n, and -n are options */
		if (start[0] == 'L' || start[0] == 'M') {
		  /* LSB or MSB is present */
		  isMSB = start[0] == 'L' ? 0 : 1;
		}
		else if (
			(start[0] == '+' || start[0] == '-')
			&& start[1] == ' '
			&& start[2] == '('
		  ) {
		  start += 3;
		  end = strchr(start, ')');
		  *end = 0;
		  carry = (byte_t) strtol(start, NULL, 16);
		  start = end + 1;
		}

		break;
	  }	/* matching operand found */
	} /* for */

	if (i == noOperandTypes) {
	  fprintf(stderr, "No matching operand: %s\n", start);
	  exit(NO_MATCHNIG_OPND);
	}

	opP->type = (OPERAND_TYPE) i;
	opP->value = opndValue;
	opP->mask = opndMask;
	opP->addr = address;
	opP->bitPos = bitPos;
	opP->isMSB = isMSB;
	opP->ext = ext;
	opP->carry = carry;

	return start;
  }
}

OPERATOR
splitSrcOpStr(char *srcOperandsStr, char *srcOP1Str, char *srcOP2Str, char *opName) {
  int noOperatorTypes = (int) (sizeof(operators)/sizeof(char *));
  int i;
  int isMove = 0, isReset = 0, isMoveCon = 0;
  char *start = srcOperandsStr, *opLoc;

  if (
	  (isMoveCon = (strstr(opName, "mov src & con, des") != NULL))
	  || (isReset = (strstr(opName, "reset") != NULL))
	  || (isMove = (strstr(opName, "mov") != NULL))
	) {
	while (*start) {
	  *srcOP1Str++ = *start++;
	}
	*srcOP1Str = 0;

	if (isReset) return RESET;
	if (isMove)  return MOVE;
	if (isMoveCon)  return MOVEC;
  } 

  for (i = 0; i < noOperatorTypes; i++) {
	if ((opLoc = strstr(start, operators[i])) != NULL) {
	  if ((OPERATOR) i == NOT) {
		start++;
		while (*start != ' ' && *start != '\0' && *start != '\t') {
		  *srcOP1Str++ = *start++;
		}
		*srcOP1Str = 0;
		return NOT;
	  } else {
		/* 
		  Example:
		  SFR_S1(02)(1) & SFR_S2(00) 
						^
						|
					  opLoc
		*/
		while (start != opLoc) {
		  *srcOP1Str++ = *start++;
		}
		*srcOP1Str = 0;

		start += strlen(operators[i]);
		start = skipWhiteSpaces(start);
		while (*start) {
		  *srcOP2Str++ = *start++;
		}
		*srcOP2Str = 0;

		return (OPERATOR) i;
	  }
	}
  }

  /* at this point, this line is move operation */
  start = srcOperandsStr;
  while (*start) {
	*srcOP1Str++ = *start++;
  }

  return ALUMOVE;
}

int 
isLineNoInList(unsigned long lineNo, GrpHeadNode *h) {

  for (; h != NULL; h = h->next) {
	if (lineNo == h->lineNo)
	  return 1;
  }
  return 0;
}

int 
insertLineNo(unsigned long lineNo, GrpHeadNode *h, GrpHeadNode **t) {
  GrpHeadNode *n;
  
  if (isLineNoInList(lineNo, h))
    return 0;
  
  n = (GrpHeadNode *) malloc(sizeof(GrpHeadNode));

  if (n == NULL) {
	fprintf(stderr, "Error: Group Head List Node allocation error\n");
	exit(GRP_HEAD_LIST_ALLOC_ERR);
  }
  n->lineNo = lineNo;
  (*t)->next = n;
  *t = n;
  return 1;
}

int
findDepDListNodes(igraph_t *pGraph, OpDListNode *nodeP) {
  static unsigned long history = 0;
  OpDListNode *opNode;
  OPERAND *src0;
  OPERAND *src1;
  OPERAND *dest = GET_DEST_OPERAND(nodeP);

  history++;
  
  for (opNode = nodeP; opNode && opNode != endNode; opNode = opNode->right) {
    src0 = GET_SRC0_OPERAND(opNode);
    src1 = GET_SRC1_OPERAND(opNode);
    if(src0 && isEqualOperand(dest, src0)) {
	  printDepNodesWithTabs(resultFP, opNode, history);

	  if (!VAN(pGraph, "Line", GET_NODE_ID_FROM_LINENO(GET_LINE_NO(opNode), nodeIDOffset))) {
		SETVAN(pGraph, "Line", GET_NODE_ID_FROM_LINENO(GET_LINE_NO(opNode), nodeIDOffset), (unsigned long) GET_LINE(opNode));

		printf("#%ld => %ld\n", GET_LINE_NO(nodeP), GET_LINE_NO(opNode));
		printf(">%ld => %ld\n", 
		  GET_NODE_ID_FROM_LINENO(GET_LINE_NO(nodeP), nodeIDOffset), 
		  GET_NODE_ID_FROM_LINENO(GET_LINE_NO(opNode), nodeIDOffset));

		igraph_add_edge(pGraph, 
			GET_NODE_ID_FROM_LINENO(GET_LINE_NO(nodeP), nodeIDOffset), 
			GET_NODE_ID_FROM_LINENO(GET_LINE_NO(opNode), nodeIDOffset)
		);
      
		findDepDListNodes(pGraph, opNode);
	  }
	}
    
	if(src1 && isEqualOperand(src1, dest)) {
      printDepNodesWithTabs(resultFP, opNode, history);

	  if (!VAN(pGraph, "Line", GET_NODE_ID_FROM_LINENO(GET_LINE_NO(opNode), nodeIDOffset))) {
		SETVAN(pGraph, "Line", GET_NODE_ID_FROM_LINENO(GET_LINE_NO(opNode), nodeIDOffset), (unsigned long) GET_LINE(opNode));

		printf("#%ld => %ld\n", GET_LINE_NO(nodeP), GET_LINE_NO(opNode));
		printf(">%ld => %ld\n", GET_NODE_ID_FROM_LINENO(GET_LINE_NO(nodeP), nodeIDOffset), GET_NODE_ID_FROM_LINENO(GET_LINE_NO(opNode), nodeIDOffset));
		igraph_add_edge(pGraph, 
			GET_NODE_ID_FROM_LINENO(GET_LINE_NO(nodeP), nodeIDOffset), 
			GET_NODE_ID_FROM_LINENO(GET_LINE_NO(opNode), nodeIDOffset)
		);

		findDepDListNodes(pGraph, opNode);
	  }
	}
  }
  history--;
  return 0;
}


/*
 node1
 node0 : start here (= nodeP)

 src0 = GET_SRC0_OPERAND(node0)
 src1 = GET_SRC1_OPERAND(node0)

 dest = GET_DEST_OPERAND(node1)

 opNode = node0
 if (dest == src0) 
   opNode = opNode->left
   findDepDListNodeReverse(opNode)

  if (dest == src1) 
   opNode = opNode->left
   findDepDListNodeReverse(opNode)

*/

int
findDepDListNodesReverse(igraph_t *pGraph, OpDListNode *nodeP) {
  static unsigned long history = 0;
  OpDListNode *opNode;
  OPERAND *src0;
  OPERAND *src1;
  OPERAND *dest;

  if (!nodeP) return 0;

  SETVAN(
	pGraph, 
	"Line",
	GET_NODE_ID_FROM_LINENO(GET_LINE_NO(nodeP), nodeIDOffset), 
	(unsigned long) GET_LINE(nodeP)
  );

  SETVAN(
	pGraph, 
	"Visited",
	GET_NODE_ID_FROM_LINENO(GET_LINE_NO(nodeP), nodeIDOffset), 
    1	
  );

  src0 = GET_SRC0_OPERAND(nodeP);
  src1 = GET_SRC1_OPERAND(nodeP);

  history++;
  
  for (opNode = nodeP->left; opNode && opNode != startNode; opNode = opNode->left) {
	dest = GET_DEST_OPERAND(opNode);

    if(src0 && isEqualOperand(dest, src0)) {
	  /*
	  printDepNodesWithTabs(resultFP, opNode, history);
	  printf("#%ld => %ld\n", GET_LINE_NO(nodeP), GET_LINE_NO(opNode));
	  printf(">%ld => %ld\n", 
		GET_NODE_ID_FROM_LINENO(GET_LINE_NO(nodeP), nodeIDOffset), 
		GET_NODE_ID_FROM_LINENO(GET_LINE_NO(opNode), nodeIDOffset));
	  */

	  igraph_add_edge(pGraph, 
		  GET_NODE_ID_FROM_LINENO(GET_LINE_NO(opNode), nodeIDOffset),
		  GET_NODE_ID_FROM_LINENO(GET_LINE_NO(nodeP), nodeIDOffset) 
	  );

	  if (!VAN(pGraph, "Visited", GET_NODE_ID_FROM_LINENO(GET_LINE_NO(opNode), nodeIDOffset))) {
		findDepDListNodesReverse(pGraph, opNode);
	  }
	}
    
	if(src1 && isEqualOperand(src1, dest)) {
	  /*
      printDepNodesWithTabs(resultFP, opNode, history);
	  printf("#%ld => %ld\n", GET_LINE_NO(nodeP), GET_LINE_NO(opNode));
	  printf(">%ld => %ld\n", 
		GET_NODE_ID_FROM_LINENO(GET_LINE_NO(nodeP), nodeIDOffset), 
		GET_NODE_ID_FROM_LINENO(GET_LINE_NO(opNode), nodeIDOffset));
	  */

	  igraph_add_edge(pGraph, 
		  GET_NODE_ID_FROM_LINENO(GET_LINE_NO(opNode), nodeIDOffset),
		  GET_NODE_ID_FROM_LINENO(GET_LINE_NO(nodeP), nodeIDOffset) 
	  );

	  if (!VAN(pGraph, "Visited", GET_NODE_ID_FROM_LINENO(GET_LINE_NO(opNode), nodeIDOffset))) {
		findDepDListNodesReverse(pGraph, opNode);
	  }
	}
  }
  history--;
  return 0;
}


void
printUsage(char *progName) {
  fprintf(stderr, "For interactive mode, use -i option\n");
  fprintf(stderr, "Usage: %s -i \n", progName);
  fprintf(stderr, "or\n");
  fprintf(stderr, "Usage: %s -c start_clock end_clock log_file\n", progName);
  fprintf(stderr, "or\n");
  fprintf(stderr, "Usage: %s -p start_pc end_pc log_file\n", progName);
  fprintf(stderr, "or\n");
  fprintf(stderr, "Usage: %s -l start_line_no end_line_no log_file\n", progName);
}

void
findRange(int rangeKind, unsigned long start, unsigned long end) {
  OpDListNode *opNode = NULL;
  if (rangeKind == RANGE_PC) {
    startNode = endNode = NULL;
    for (opNode = OpDListHead; opNode; opNode = opNode->right) {
      if (startNode == NULL && opNode->lineP->pc == start) {
        startNode = opNode;
		startLine = GET_LINE_NO(startNode);
      }

      if (endNode == NULL && opNode->lineP->pc == end) {
        OpDListNode *t;
        for (t = opNode; t && t->lineP->pc == end; t = t->right) {
          endNode = t;
		  endLine = GET_LINE_NO(endNode);
        }
        break;
      }
    }
  } else if (rangeKind == RANGE_LINE_NO) {
    startNode = endNode = NULL;
    for (opNode = OpDListHead; opNode; ) {
      if (startNode == NULL && GET_LINE_NO(opNode) == start) {
        startNode = opNode;
		noOfGraphNodes++;
      }

      if (endNode == NULL && GET_LINE_NO(opNode) == end) {
        endNode = opNode;
        break;
      }

	  if (noOfGraphNodes) 
		noOfGraphNodes++;

      opNode = opNode->right;
    }
  }
}



#if 0
void delete_isolated_vertices(igraph_t *pg) {
  igraph_vs_t vs2;
  igraph_vit_t vit2;

  /* delete isolated verices */
  igraph_vs_all(&vs2);

  /* creates a vertex iterator from a vertex selector */
  igraph_vit_create(pg, vs2, &vit2);

  while (!IGRAPH_VIT_END(vit2)) {
	igraph_integer_t deg;
	igraph_integer_t vid;

	vid = IGRAPH_VIT_GET(vit2);
	IGRAPH_CHECK(igraph_degree_1(pg, &deg, vid, IGRAPH_ALL, IGRAPH_LOOPS));

	if (deg == 0) {
	  igraph_delete_vertices(pg, igraph_vss_1(vid));
	}

	/* get next vertex */
	IGRAPH_VIT_NEXT(vit2);
  }

  igraph_vs_destroy(&vs2);
  igraph_vit_destroy(&vit2);
}
#endif


#define IS_PRINT_OPND_ONLY 0
int
main(int argc, char *argv[]) {
  FILE *fp;
  FILE *fpDot, *fpLgl;
  char lineStr[MAX_LINE_LEN], *p;
  char opName[OPNAME_SIZE];
  char logFileName[LOG_FILENAME_SIZE];
  char resultFileName[LOG_FILENAME_SIZE];
  char srcOP0Str[20], srcOP1Str[20];
  char *srcOperandsStr, *destOperandStr;
  int readLineResult;
  int rangeKind = RANGE_CLOCK;
  int interactiveMode = 0;

  int answer;
  char ansStr[3];
  char pattern_lgl_fname[30], pattern_dot_fname[30];
  FILE *pattern_lgl_fp,*pattern_dot_fp;

  PATTERN_NODE *pn;	/* pattern DB */
  OpDListNode *opDNode;

  igraph_t pattern_graph, log_graph;
  igraph_vs_t vs, vs2;
  igraph_vit_t vit, vit2;

  igraph_graph_list_t temp_complist, complist, log_complist, pattern_complist;
  igraph_vector_ptr_t pt_vec;

  igraph_integer_t i, j;

  isoReNode *IR_HEAD = NULL, *IR_TAIL = NULL;

  /* Turn on attribute handling. */
  igraph_set_attribute_table(&igraph_cattribute_table);

  clk_t clk, startClk = 0, endClk = 0;
  pc_t pc, startPC = 0, endPC = 0;
  byte_t fieldA, fieldB;
  OPERAND *destOperandP;
  OPERAND *srcOp0P, *srcOp1P;
  OPERATOR op;
  OPERATION *operationP;
  LogLine *lineP;


  /*
  logAnalyzer -c start_clock end_clock log_file
  logAnalyzer -p start_pc end_pc log_file
  */
  /*
  if (argc == 2 || 1) {
    if (!strcmp(argv[1], "-i")) {
      interactiveMode = 1;
    }
  } else if (argc != NO_ARGC) {
    printUsage(argv[0]);
	exit(USAGE_ERR);
  }
  */
  interactiveMode = 1;
  
  initOpDList();

  printf("Interactive mode:\n");
  printf(">>> Input log file name: ");
  
  scanf("%s", logFileName);
  if ((fp = fopen(logFileName, "r")) == NULL) {
	fprintf(stderr, "File open error\n");
	return FILE_OPEN_ERR;
  }

  /*
  printf(">>> Output file name (for monitor input stdout): ");
  
  scanf("%s", resultFileName);
  if (!strcmp(resultFileName, "stdout"))
	resultFP = stdout;
  else if ((resultFP = fopen(resultFileName, "w")) == NULL) {
	fprintf(stderr, "File open error\n");
	return FILE_OPEN_ERR;
  }
  */
  
  fprintf(stderr, "Reading log file %s ...\n", logFileName);

  /*
   * Read log file and construct a double-linked list
   */
  p = lineStr;
  readLineResult = readLine(fp, p, MAX_LINE_LEN);
  while (readLineResult != EOF && readLineResult != RD_WR_ERR) {
	lineP = (LogLine *) malloc(sizeof(LogLine));
    lineP->lineNo = lineNo;
	strcpy(lineP->strLine, p);

	DBG1_PRINT("Line: %s", p);
	
    p = getClk(p, &clk);
	DBG1_PRINT("\tCLK: %lx\n", clk);

	p = getPC(p, &pc);
    DBG1_PRINT("\tPC: %lx\n", pc);

	p = getFieldA(p, &fieldA);
    DBG1_PRINT("\tFIELDA: %x\n", fieldA);

	p = getFieldB(p, &fieldB);
    DBG1_PRINT("\tFIELDB: %x\n", fieldB);

	p = getOpName(p, opName);
	DBG1_PRINT("\tOP NAME: %s\n", opName);
	DBG1_PRINT("\tDescription: %s\n", p);

	getOperandsStr (p, &srcOperandsStr, &destOperandStr);
	DBG1_PRINT("\tsrcOperandsStr: %s || destOperandStr: %s\n", srcOperandsStr, destOperandStr);

	srcOP0Str[0] = 0;
	srcOP1Str[0] = 0;
	op = splitSrcOpStr(srcOperandsStr, srcOP0Str, srcOP1Str, opName);
	DBG1_PRINT("\tOP: %s\n", operatorNameStrs[(int) op]);
	DBG1_PRINT("\tsrcOP0Str: %s\n", srcOP0Str);
	if(
		op != MOVE && 
		op != RESET && 
		op != MOVEC && 
		op != ALUMOVE &&
		op != NOT
	  ) 
	  DBG1_PRINT("\tsrcOP1Str: %s\n", srcOP1Str);

	srcOp0P = srcOp1P = destOperandP = NULL;
	srcOp0P = (OPERAND *) malloc(sizeof(OPERAND));
	p = parseOperand(srcOP0Str, srcOp0P);
	printOperand(resultFP, SRC0_OPERAND, srcOp0P, IS_PRINT_OPND_ONLY);

	if(
		op != MOVE && 
		op != RESET && 
		op != MOVEC && 
		op != ALUMOVE &&
		op != NOT
	  ) {
		if ((op == LSHIFT || op == RSHIFT) && srcOP1Str[0] != '(') {
		  int j, len = (int) strlen(srcOP1Str);
		  char tempStr[30];
		  tempStr[0] = '(';
		  for (j = 0; j < len; j++) {
			tempStr[j+1] = srcOP1Str[j];
		  }
		  tempStr[j+1] = ')';
		  tempStr[j+2] = 0;
		  strcpy(srcOP1Str, tempStr);
		}
		srcOp1P = (OPERAND *) malloc(sizeof(OPERAND));
		p = parseOperand(srcOP1Str, srcOp1P);
		printOperand(resultFP, SRC1_OPERAND, srcOp1P, IS_PRINT_OPND_ONLY);
	}

	destOperandP = (OPERAND *) malloc(sizeof(OPERAND));
	p = parseOperand(destOperandStr, destOperandP);	// actually p is not used beyond this point
	printOperand(resultFP, DEST_OPERAND, destOperandP, IS_PRINT_OPND_ONLY);

	operationP = (OPERATION *) malloc(sizeof(OPERATION));
	operationP->op = op;
	operationP->dest = destOperandP;
	operationP->src[0] = srcOp0P ;
	operationP->src[1] = srcOp1P ;
	// printOperation(operationP);

	lineP->clock = clk;
	lineP->pc = pc;
	lineP->fieldA = fieldA;
	lineP->fieldB = fieldB;
	strncpy(lineP->opName, opName, OPNAME_SIZE-2);
	lineP->opP = operationP;
	// printLogLine(lineP, 0);
	insertLast(lineP);

	/* read next line in log file */
	readLineResult = readLine(fp, lineStr, MAX_LINE_LEN);
	p = lineStr;
  }

  /*
  printf(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n");
  for (opNode = OpDListHead; opNode; ) {
	printOpDListNode(opNode);
	opNode = opNode->right;
  }
  printf(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n");
  */

  fprintf(stderr, "### Done reading log file...\n");
  
  fprintf(stderr, "### Reading and pattern.in and generating PatternDB ...\n");
  parse_pattern_file("pattern.in");
  fprintf(stderr, "### Following patterns are read...\n");
  print_pattern_list();

  for (pn = pattern_head; pn ; pn = pn->link) {
	/*
	  pattern (pn) has PCs of start and end points.
	*/
	findRange(RANGE_PC, pn->pattern_data->start_pc, pn->pattern_data->end_pc);
	pn->pattern_data->start_lineno = startLine;
	pn->pattern_data->end_lineno = endLine;
	noOfGraphNodes = endLine - startLine + 1;

	/* Create a directed graph with no vertices or edges. */
	igraph_empty(&(pn->pattern_data->pg), 0, IGRAPH_DIRECTED);

	/* Add noOfGraphNodes vertices. Vertex IDs will range from 0 to noOfGraphNodes-1, inclusive. */
	printf("noOfGraphNodes = %lu\n", noOfGraphNodes);
	igraph_add_vertices(&(pn->pattern_data->pg), noOfGraphNodes, NULL);

	// printf("HERE 77\n");
	igraph_vs_all(&vs);

	// printf("HERE 78\n");
	/* creates a vertex iterator from a vertex selector */
	igraph_vit_create(&(pn->pattern_data->pg), vs, &vit);

	while (!IGRAPH_VIT_END(vit)) {
	  /* initalize the attribute "Line" with 0 
	   * When making graphs this attribute is set with the pointer to OpDListNode 
	   * which contains all data of each log line in
	   * findDepDlistNodes.
	   */
	  /*
	   * IGRAPH_VIT_GET returns the vertex ID of the current vertex 
	   * SETVAN(graph, name, vid, value): the attribute (name) of vertex vid is set with value
	   */
	  // SETVAN(&graph, "Line", IGRAPH_VIT_GET(vit), 0);
	  SETVAN(&(pn->pattern_data->pg), "Visited", IGRAPH_VIT_GET(vit), 0);

	  /* get next vertex */
	  IGRAPH_VIT_NEXT(vit);
	}

	
	DBG1_PRINT("sizeof(operandNameStrs) = %ld\n", sizeof(operandNameStrs));
	DBG1_PRINT("sizeof(operandNameStrs)/sizeof(char *) = %ld\n", sizeof(operandNameStrs)/sizeof(char *));

	resultFP = stdout;
	nodeIDOffset = startLine;
	fprintf(resultFP, "PatternDB Gerating starts ... : %s\n", pn->pattern_data->fun);

	opDNode = endNode;
	while (opDNode != startNode) {
	  // printDepNodesWithTabs(resultFP, opDNode, 0);
	  findDepDListNodesReverse(&(pn->pattern_data->pg), opDNode);
	  opDNode = opDNode->left;
	}

	SETVAN(
	  &(pn->pattern_data->pg), 
	  "Line",
	  GET_NODE_ID_FROM_LINENO(GET_LINE_NO(startNode), nodeIDOffset), 
	  (unsigned long) GET_LINE(startNode)
	);

	igraph_simplify(&(pn->pattern_data->pg), true, true, /*edge_comb=*/ NULL);

	igraph_graph_list_init(&complist, 0);
	igraph_decompose(&(pn->pattern_data->pg), &complist, IGRAPH_WEAK, -1, 2);

#if 0
	/* remove isomorphic pattern */
	igraph_graph_list_init(&temp_complist, 0);
	igraph_vector_ptr_init(&pt_vec, igraph_graph_list_size(&complist));
	for (i = 0; i < igraph_graph_list_size(&complist); i++) {
	  igraph_t *g1;
	  g1 = igraph_graph_list_get_ptr(&complist, i);
	  igraph_vector_ptr_push_back(&pt_vec, g1);
	}

	for (i = 0; i < igraph_vector_ptr_size(&pt_vec); i++) {
	  igraph_t *g1, *g2;
	  g1 = igraph_vector_ptr_get(&pt_vec, i);
	  for (j = i+1; j < igraph_vector_ptr_size(&pt_vec); j++) {
		igraph_bool_t iso12 = false; // graph2 is isomorphic to a subgraph of graph1, graph1 > graph2
		igraph_bool_t iso21 = false; // graph1 is isomorphic to a subgraph of graph1, graph2 > graph1
		
		g2 = igraph_vector_ptr_get(&pt_vec, j);
		igraph_subisomorphic(g1, g2, &iso12);
		igraph_subisomorphic(g2, g1, &iso21);

		if (iso12) {
		  /* g1 is added and g2 is removed */
			igraph_graph_list_push_back(&temp_complist, g1);
		} else if (iso21) {
		  /* g2 is added and g1 is removed */
			igraph_graph_list_push_back(&temp_complist, g2);
		}

	  }
	}

	for (i = 0; i < igraph_graph_list_size(&complist)-1; i++) {
	  igraph_t *g1, *g2;
	  g1 = igraph_graph_list_get_ptr(&complist, i);

	  for (j = i+1; j < igraph_graph_list_size(&complist); j++) {
		igraph_bool_t iso12 = false; // graph2 is isomorphic to a subgraph of graph1, graph1 > graph2
		igraph_bool_t iso21 = false; // graph1 is isomorphic to a subgraph of graph1, graph2 > graph1
		
        g2 = igraph_graph_list_get_ptr(&complist, j);

		igraph_subisomorphic(g1, g2, &iso12);
		igraph_subisomorphic(g2, g1, &iso21);

		if (iso12) {
		  /* g1 is added and g2 is removed */
			igraph_graph_list_push_back(&temp_complist, g1);
		} else if (iso21) {
		  /* g2 is added and g1 is removed */
			igraph_graph_list_push_back(&temp_complist, g2);
		}
	  }
    }


	// igraph_graph_list_clear(&complist);
	printf("############### %s = %ld\n", pn->pattern_data->fun, igraph_graph_list_size(&temp_complist));
	pn->pattern_data->complist = temp_complist;
#endif
	printf("############### %s = %ld\n", pn->pattern_data->fun, igraph_graph_list_size(&complist));
	pn->pattern_data->complist = complist;

	// igraph_graph_list_clear(&temp_complist);

	/*
	 * Output files for patterns (described in pattern.in)
	 * pattern_name.dot: Dot file for each pattern
	 * pattern_name.lgl: Lgl file for each pattern
	 */
	sprintf(pattern_lgl_fname, "%s.lgl", pn->pattern_data->fun);
	sprintf(pattern_dot_fname, "%s.dot", pn->pattern_data->fun);
	pattern_lgl_fp = fopen(pattern_lgl_fname, "w");
	if (pattern_lgl_fp == NULL) {
	  fprintf(stderr, "Pattern LGL file open error\n");
	  return FILE_OPEN_ERR;
	}
	pattern_dot_fp = fopen(pattern_dot_fname, "w");
	if (pattern_dot_fp == NULL) {
	  fprintf(stderr, "Pattern DOT file open error\n");
	  return FILE_OPEN_ERR;
	}

	igraph_write_graph_dot(&(pn->pattern_data->pg), pattern_dot_fp);
	igraph_write_graph_lgl(&(pn->pattern_data->pg), pattern_lgl_fp, NULL, NULL, /*isolates*/ 0);

	/*
	fprintf(resultFP, "\n#########################\n");
	fprintf(resultFP, "\tfun: %s\n", pn->pattern_data->fun);
	fprintf(resultFP, "\tstart_pc: %lx\n", pn->pattern_data->start_pc);
	fprintf(resultFP, "\tend_pc: %lx\n", pn->pattern_data->end_pc);
	fprintf(resultFP, "\tstart_line: %ld\n", pn->pattern_data->start_lineno);
	fprintf(resultFP, "\tend_line: %ld\n", pn->pattern_data->end_lineno);
	*/

	fclose(pattern_dot_fp);
	fclose(pattern_lgl_fp);
	// igraph_destroy(&pattern_graph);
  }
  fprintf(stderr, "### Done generating PatternDB ...\n");

  while (1) {
	/* while user wants to continue analysis */
	getchar();
	printf("Input range type \"p\" for pc, \"l\" for line numer or \"e\" to exit: ");
	fgets(ansStr, 2, stdin);
	answer = ansStr[0];

	if (answer != 'p' && answer != 'l' && answer != 'e') {
	  printf("Answer must be p, l or e\n");
	  continue;
	}
	else if (answer == 'e') {
	  printf("### Good-bye\n");
	  break;
	}
	else {
	  char startValue[10], endValue[10];
	  printf("Input start value (decimal for line number and hexadecimal for PC) : ");
	  scanf("%s", startValue);
	  
	  printf("Input end value (decimal for line number and hexadecimal for PC) : ");
	  scanf("%s", endValue);
	  
	  if (answer == 'l') {
		startLine = (line_no_t) strtol(startValue, NULL, 10);
		endLine = (line_no_t) strtol(endValue, NULL, 10);
		rangeKind = RANGE_LINE_NO;
		if (startLine >= endLine) {
		  fprintf(stderr, "Range error: start line number < end line number\n");
		  continue;
		}
	  } else if (answer == 'p') {
		startPC = (pc_t) strtol(startValue, NULL, 16);
		endPC = (pc_t) strtol(endValue, NULL, 16);
		rangeKind = RANGE_PC;
		if (startPC >= endPC) {
		  fprintf(stderr, "Range error: start PC < end PC\n");
		  continue;
		}
	  }
	  
	  noOfGraphNodes = 0;
	  /*
	   find two nodes in the doble-linked list corresponding to startLine (or startPC) and endLine(or endPC)
	   Variables startNode and endNode are set.
	   */
	  if (rangeKind == RANGE_PC) {
		findRange(rangeKind, startPC, endPC);
	  } else if (rangeKind == RANGE_LINE_NO) {
		findRange(rangeKind, startLine, endLine);
	  }

	  noOfGraphNodes = endLine - startLine + 1;
	  nodeIDOffset = startLine;

	  /* Create a directed graph with no vertices or edges. */
	  igraph_empty(&log_graph, 0, IGRAPH_DIRECTED);

	  /* Add noOfGraphNodes vertices. Vertex IDs will range from 0 to noOfGraphNodes-1, inclusive. */
	  printf("noOfGraphNodes = %lu\n", noOfGraphNodes);
	  igraph_add_vertices(&log_graph, noOfGraphNodes, NULL);

	  // printf("HERE 7\n");
	  igraph_vs_all(&vs);

	  // printf("HERE 8\n");
	  /* creates a vertex iterator from a vertex selector */
	  igraph_vit_create(&log_graph, vs, &vit);

	  while (!IGRAPH_VIT_END(vit)) {
		/* initalize the attribute "Line" with 0 
		 * When making graphs this attribute is set with the pointer to OpDListNode which contains all data 
		 * of each log line in findDepDlistNodes.
		 */
		/*
		 * IGRAPH_VIT_GET returns the vertex ID of the current vertex 
		 * SETVAN(graph, name, vid, value): the attribute (name) of vertex vid is set with value
		 */
		// SETVAN(&graph, "Line", IGRAPH_VIT_GET(vit), 0);
		SETVAN(&log_graph, "Visited", IGRAPH_VIT_GET(vit), 0);

		/* get next vertex */
		IGRAPH_VIT_NEXT(vit);
	  }
	  igraph_vs_destroy(&vs);
	  igraph_vit_destroy(&vit);

	  printf(">>> Output file name (for monitor input stdout): ");
	  scanf("%s", resultFileName);
	  if (!strcmp(resultFileName, "stdout"))
		resultFP = stdout;
	  else if ((resultFP = fopen(resultFileName, "w")) == NULL) {
		fprintf(stderr, "File open error\n");
		return FILE_OPEN_ERR;
	  }
			  
	  DBG1_PRINT("sizeof(operandNameStrs) = %ld\n", sizeof(operandNameStrs));
	  DBG1_PRINT("sizeof(operandNameStrs)/sizeof(char *) = %ld\n", sizeof(operandNameStrs)/sizeof(char *));

	  /* construct a log graph for the entire log file */
	  fprintf(resultFP, "Starting from : \n");
	  opDNode = endNode;
	  while (opDNode != startNode) {
		printDepNodesWithTabs(resultFP, opDNode, 0);
		findDepDListNodesReverse(&log_graph, opDNode);
		opDNode = opDNode->left;
	  }

	  SETVAN(
		&log_graph, 
		"Line",
		GET_NODE_ID_FROM_LINENO(GET_LINE_NO(startNode), nodeIDOffset), 
		(unsigned long) GET_LINE(startNode)
	  );
	  
	  igraph_simplify(&log_graph, true, true, /*edge_comb=*/ NULL);

	  if (resultFP != stdout) fclose(resultFP);
	  {
		/* open a dot file */
		char dotFileName[LOG_FILENAME_SIZE+5];
		char lglFileName[LOG_FILENAME_SIZE+5];
		if (resultFP != stdout) {
		  sprintf(dotFileName, "%s.dot", resultFileName);
		  sprintf(lglFileName, "%s.lgl", resultFileName);
		} else {
		  sprintf(dotFileName, "outgraph.dot");
		  sprintf(lglFileName, "outgraph.lgl");
		}

		if ((fpDot = fopen(dotFileName, "w")) == NULL) {
		  fprintf(stderr, "Dot file open error\n");
		  return FILE_OPEN_ERR;
		}

		if ((fpLgl = fopen(lglFileName, "w")) == NULL) {
		  fprintf(stderr, "LGL file open error\n");
		  return FILE_OPEN_ERR;
		}
	  }


	  {
		igraph_bool_t res;

		igraph_is_simple(&log_graph, &res);
		printf("\tIs log graph simple: %d\n", res);

		igraph_has_loop(&log_graph, &res);
		printf("\tDoes log graph have loop: %d\n", res);

		igraph_has_multiple(&log_graph, &res);
		printf("\tDoes log graph have multiple: %d\n", res);

	  }

	  igraph_write_graph_lgl(&log_graph, fpLgl, NULL, NULL, /*isolates*/ 1);
	  igraph_write_graph_dot(&log_graph, fpDot);
	  fclose(fpLgl);
	  fclose(fpDot);

	  igraph_graph_list_init(&log_complist, 0);
	  /*
		Creates a separate graph for each component of log a graph.
	  */
	  printf("### Decompose the log graph into components: \n");
	  igraph_decompose(&log_graph, &log_complist, IGRAPH_WEAK, -1, 2);
	  

	  /* for each log component find isomorphic from pattern */
	  printf("### Find patterns in each component: \n");
	  for (i = 0; i < igraph_graph_list_size(&log_complist); i++) {
		FILE *fp_log;
		char fp_log_name[30];
		igraph_t *log_component;

		sprintf(fp_log_name, "log%ld.dot", i);
		fp_log = fopen(fp_log_name, "w");

        log_component = igraph_graph_list_get_ptr(&log_complist, i);
        igraph_write_graph_dot(log_component, fp_log);
		fclose(fp_log);

		for (pn = pattern_head; pn ; pn = pn->link) {
		  igraph_graph_list_t pattern_compilst;

		  // printf("######################################\n");

		  /*
		   * for a log component, iterate over a pattern list
		   * find isomorphism
		   */
		  pattern_complist = pn->pattern_data->complist;
		  for (j = 0; j < igraph_graph_list_size(&(pattern_complist)); j++) {
			igraph_t *pattern_component;
			igraph_vector_int_t vmap12, vmap21;
			igraph_integer_t sub_iso_count = 0;
			igraph_bool_t iso;
			igraph_vector_int_t map;
			igraph_vector_int_list_t maps, vmaps;
			char pattern_comp_name[30];
			FILE *fp_pattern_comp;

			printf("##### Search Log No.: %ld for Pattern: %s(%ld)\n", i, pn->pattern_data->fun, j);

			igraph_vector_int_init(&map, 0);
			igraph_vector_int_list_init(&maps, 0);
			igraph_vector_int_init(&vmap12, 0);
			igraph_vector_int_init(&vmap21, 0);
			igraph_vector_int_list_init(&vmaps, 0);

			pattern_component = igraph_graph_list_get_ptr(&(pattern_complist), j);

			sprintf(pattern_comp_name, "pt_%s_%ld.dot", pn->pattern_data->fun, j);
			fp_pattern_comp = fopen(pattern_comp_name, "w");
			igraph_write_graph_dot(pattern_component, fp_pattern_comp);
			fclose(fp_pattern_comp);

			// printf("  >>>> log: %ld, pattern: %s(%ld)\n", i, pn->pattern_data->fun, j);

			if (igraph_vcount(log_component) < igraph_vcount(pattern_component)) {
			  printf("##### Log No. %ld has less node than Pattern %s(%ld) has\n", 
					i, pn->pattern_data->fun, j);
			  continue;
			}

#if 1
#if 0
			igraph_count_subisomorphisms_vf2(
			  /* graph1= */ log_component,
			  /* graph2= */ pattern_component,
			  /* vertex_color1= */ NULL,
			  /* vertex_color1= */ NULL,
			  /* edge_color1= */ NULL,
			  /* edge_color1= */ NULL,
			  /* count= */ &sub_iso_count,
			  /* node_compat_fn= */ is_equal_node,
			  /* edge_compat_fn= */ NULL,
			  /* arg= */ 0);
			// printf("  \t>>>> No. of subisomorphic graph = %ld)-----\n", sub_iso_count);
#endif

			igraph_subisomorphic_vf2(
			  /* graph1= */ log_component,
			  /* graph2= */ pattern_component,
			  /* vertex_color1= */ NULL,
			  /* vertex_color1= */ NULL,
			  /* edge_color1= */ NULL,
			  /* edge_color1= */ NULL,
			  /* iso= */ &iso,
			  /* map12= */ &vmap12,
			  /* map21= */ &vmap21,
			  /* node_compat_fn= */ is_equal_node,
			  /* edge_compat_fn= */ NULL,
			  /* arg= */ 0);

			if (iso) {
			  /*
			  printf("  \t>>>>  map 1 (log_graph, larger graph) ==> 2(pattern_g, smaller graph)\n");
	 		  print_map(&vmap12);
			  */
			  print_iso(log_component, vmap12, pn->pattern_data->fun, i, j);
			  if (IR_HEAD == NULL) {
				IR_HEAD = (isoReNode *) malloc(sizeof(isoReNode));
				setISOResultNode(log_component, IR_HEAD, vmap12, /* log no */ i, /* pattern no */ j, pn);
				IR_TAIL = IR_HEAD;
				IR_HEAD->link = NULL;
			  } else {
				isoReNode *temp;
				temp = (isoReNode *) malloc(sizeof(isoReNode));
				setISOResultNode(log_component, temp, vmap12, /* log no */ i, /* pattern no */ j, pn);
				IR_TAIL->link = temp;
				IR_TAIL = temp;
				temp->link = NULL;
			  }
			  /*
			  printf("  \t>>>>  map 2 (pattern_g, smaller graph) ==> 1(log_graph, larger graph)\n");
			  print_map(&vmap21);
			  printf("  \t>>>>  all mappings \n");
			  print_maps(&vmap21, &vmaps);
			  printf("  \t>>>>  map 1 (log_graph, larger graph) ==> 2(pattern_g, smaller graph)\n");
			  print_map(&vmap12);
			  printf("  \t>>>>  map 2 (pattern_g, smaller graph) ==> 1(log_graph, larger graph)\n");
			  print_map(&vmap21);
			  */
			}
#else
			igraph_subisomorphic_lad(pattern_component, log_component, NULL, &iso, &map, &maps, 
				  /*induced=*/ true, /*time_limit=*/ 0);
			printf("\n\n----- lad (domain, induced) -----\n");
			print_maps(&map, &maps);
#endif
			igraph_vector_int_destroy(&map);
			igraph_vector_int_list_destroy(&maps);
		  }
		}
	  }


	  /* Print results here */
	  {
		igraph_vs_t vs_t;
		igraph_vit_t vit_t;
		igraph_vs_all(&vs_t);
		isoReNode *tn;

		printf("############# ISO Results...\n");
		for (tn = IR_HEAD; tn; tn = tn->link) {
		  printf("\tLog: %d, %s(%d), start = %d, end = %d\n", 
			(tn->result).log_no, 
			(tn->result).pn->pattern_data->fun, 
			(tn->result).pattern_no, 
			(tn->result).start, 
			(tn->result).end
			);
		}

		igraph_vit_create(&log_graph, vs_t, &vit_t);

		while (!IGRAPH_VIT_END(vit_t)) {
		  int index = IGRAPH_VIT_GET(vit_t);
		  unsigned long temp;
		  LogLine *log_lineP;
		  int current_lineNo;

		  temp = (unsigned long) VAN(&log_graph, "Line", index);
		  log_lineP = (LogLine *)temp;
		  current_lineNo = log_lineP->lineNo;

		  /*
		  for (tn = IR_HEAD; tn; tn = tn->link) {
			if (current_lineNo >= (tn->result).start && current_lineNo <= (tn->result).end) {
			  if (curretn_lineNo == (tn->ersult).start) {
				fprintf(stdout, "\tLog: %d, %s, start = %d, end = %d\n", 
				  (tn->result).log_no, 
				  (tn->result).pn->pattern_data->fun, 
				  (tn->result).start, 
				  (tn->result).end
				);
			  } else {
				IGRAPH_VIT_NEXT(vit_t);
				continue;
			  }
			}
		  }
		  */

		  if (log_lineP) printMatchLogLine(stdout, log_lineP, 1);
		  IGRAPH_VIT_NEXT(vit_t);
		}
	}

	igraph_destroy(&log_graph);
  }

#if 0
	{
	  // for test
	  LogLine *lineP;
	  unsigned long temp;

	  temp = (unsigned long) VAN(&graph, "Line", 981);

	  lineP = (LogLine *) temp;
	  printLogLine(stdout, lineP, 1);
	}
#endif
  }
}
